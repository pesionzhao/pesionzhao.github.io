## C++

### 关键字

- `const` 代表常量,不能被修改, **const默认与其左边结合，当左边没有任何东西则与右边结合。**, 也就是const int* 等价于 int const*

[C++里 const int* 与 int const* 有什么区别？](https://www.zhihu.com/question/443195492/answer/1723886545)

对于int* const，则是表示一旦得到了某个变量的地址，不能改变其地址也就是不能再指向其他变量,但是可以修改指向的内容,**也就是栈区int*类型的变量无法修改**

对于int const * 表示不能修改指向的内容,但是可以修改指针的地址,**也就是堆区的指向无法修改**

**数组名和指针的关系** [C/C++数组名与指针区别深入探索](https://blog.csdn.net/ljob2006/article/details/4872167)

对数组进行`sizeof()`返回数组长度乘元素长度, 对指针进行`sizeof()`是指针的长度,取决操作系统地址总线

简单来说,数组名指代一种数据结构,且可作为指针常量(也即是不能修改,自增之类操作),数组名作为函数形参时，在函数体内，其失去了本身的内涵，仅仅只是一个指针,且失去了常量特性

成员函数后加`const`表示该函数不修改类成员

- `static` 全局的静态变量在程序启动前就会初始化, 局部静态变量在第一次调用该语句的时候才会初始化

**修饰函数**: 函数只能在本文件内引用，其他文件是不可以调用这个函数的。

**修饰成员函数**: 调用的时候可以不依赖对象，直接类名然后函数名就可以调用。

**修饰成员变量**: 存储在data段，不属于对象私有，类实例化的对象共享一个变量。

**修饰全局变量**: 存储在data段，只有本文件可见

**修饰局部变量**: 存储在data段，只有本文件可见，只在第一次使用的时候初始化一次，后面不会在初始化。

- `sizeof` 对数组: 数组所占空间大小, 对指针: 指针本身的大小(64位操作系统为8字节,32位为4字节,取决于操作系统位数,CPU字长,编译器)
- `const_cast` 去除**指针或引用**的const属性, 对常量没用,利用指针对其更改
- `static_cast` 用于非多态类型转换(静态转换)，任何标准转换都可以用它，但是不能用于两个不相关的类型转换。
- `dynamic_cast` 用于将一个父类对象的指针转换为子类对象的指针或引用
- `reinterpret_cast` 不推荐 将一种类型转换为另一种不同的类型。
- `volatile​​​​​​​` 保持内存可见性（CPU每次处理这个被volatile修饰的变量的时候，都会从内存中重新加载变量的值到寄存器）


### 智能指针
用来解决内存泄漏, RAII思想

#### unique_ptr
独占智能指针,不允许通过赋值将一个unique_ptr赋值给另一个unique_ptr,但可以通过函数返回给其他的unique_ptr，还可以通过std::move来转移到其他的unique_ptr，这样它本身就不再拥有原来指针的所有权了。

#### shared_ptr
比智能指针多了一个引用计数,也就是说一个指针有多个引用对象时,当最后一个shared_ptr析构时,其内存才会被释放

shared_ptr和unique_ptr的使用场景是要根据实际应用需求来选择。如果希望只有一个智能指针管理资源或者管理数组就用unique_ptr，如果希望多个智能指针管理同一个资源就用shared_ptr。

#### weak_ptr
有一点share_ptr智能指针还是有内存泄露的情况，当两个对象相互 使用一个shared_ptr成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏。

>未完待续

### 右值引用
对于马上就要销毁的变量的引用

比如
```c++
3;
x+y;
```

用`&&`声明, 作用为**移动语义**和**完美转发**, 比如有些对象注定要销毁,但我们还希望对其进行复制和延展

### 删除函数

阻止编译器对某些成员函数的生成,例如阻止类的复制和拷贝构造操作

在拷贝操作和复制操作函数后加`=delete`,也就成了只移类型

### 默认函数

显示要求编译器生成某些成员函数 `=default`

### constexpr
它表示 constant（常数）表达式, 不能修改, 并在编译时计算而不是运行时,c++11标准的constexpr函数要求如下

- 函数的返回类型和参数必须是字面类型。
- 函数体必须包含一个单一的 return 语句（在 C++11 中），或可以包含多条语句（在 C++14 及更高版本中）

constexpr 和 const 都表示常量，但它们有一些重要的区别：

- const 变量的值在运行时确定，尽管它不可变。
- constexpr 变量的值在编译时确定，是编译时常量。

### lambda表达式

[C++ Lambda表达式的完整介绍](https://zhuanlan.zhihu.com/p/384314474)

使用std::function在函数内部构造dfs时经常使用！！

```c++
function<int(int, int, int)> dfs = [&](int t, int j, int k) -> int
{};
function<void(int)> dfs = [&](int i){};
```

lambda表达式语法

`[capture list] (params list) mutable exception-> return type { function body }`

`[capture list]`中为捕获的参数, 分为值捕获和引用捕获,例如

`[]`: 不捕获任何变量
`[&]`: 以引用方式捕获所有外部变量
`[=]`: 以值的方式捕获所有外部变量
`[=]`: 以值的方式捕获所有外部变量
`[=,&x]`: 以引用方式捕获x,其余都用值
`[&,x]`: 以值方式捕获x,其余都用引用

`(params list)`函数参数列表

`mutable`指示符：用来说用是否可以修改捕获的变量

`exception`：异常设定

多态与虚函数

[C++ 虚函数和纯虚函数的区别](https://www.runoob.com/w3cnote/cpp-virtual-functions.html)

- 简单来说,有纯虚函数的类为抽象类,不能实例化,他的派生类需要给出该纯虚函数的实现方法才能进行实例化

- 对于虚函数来说，父类和子类都有各自的版本。由多态方式调用的时候动态绑定。